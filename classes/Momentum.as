// Momentum Class// An abstract mathimatic momentum emulator based on Timer// With overflow elasticity// (cc) 2010 Jam Zhang// jammind@gmail.compackage {		import flash.events.TimerEvent;	import flash.utils.Timer;	public class Momentum {				private static const _overflowAmplitude:Number=50; // in Pixel		private static const STATUS_HOLD:int=0; // not moving		private static const STATUS_RELEASED:int=1; // released and moving with intertia		private static const STATUS_OVERFLOW:int=2; // released and overflow and moving with elasticity		private static const STATUS_NORMALIZED:int=3; // finished with elasticity				private var status:int;		private var _currentValue:Number;		private var _currentSpeed:Number;		private var _releaseSpeed:Number;		private var _bufferLength:int;		private var _interval:Number; // step interval in Milliseconds		private var _decayTime:Number; // in Milliseconds		private var _decayTimer:Number;		private var _minValue:Number;		private var _maxValue:Number;				private var overflowSpeed:Number; // s0		private var overflowY0:Number; // initial value		private var overflowY1:Number; // final value		private var overflowT:Number; // total overflow transition time in Milliseconds		private var overflowT1:Number=100; // in Milliseconds		private var overflowT2:Number; // slow down phase transition time in Milliseconds		private var overflowYMax:Number;		private var overflowTimer:Number;		private var _overflowDeacceleration:Number=.1; // (slowdown) in Pixels per Millisecind				private var valueLog:Array=[];		private var logged:Boolean=false;		private var timer:Timer=null;						//interval:Number in Miliseconds		public function Momentum(data:Object=null):void {			start(data);		}				public function start(data:Object=null):void {			if(data==null) {				data={};			}			if (data.initValue==undefined) {				data.initValue=0;			}			if (data.bufferLength==undefined) {				data.bufferLength=5;			}			if (data.decayTime==undefined) {				data.decayTime=1000;			}			if (data.interval==undefined) {				data.interval=25;			}			if (data.minValue==undefined) {				data.minValue=Number.MIN_VALUE;			}			if (data.maxValue==undefined) {				data.maxValue=Number.MAX_VALUE;			}						with(data) {				_currentValue=initValue;				_bufferLength=bufferLength;				_interval=interval;				_decayTime=decayTime;				_minValue=minValue;				_maxValue=maxValue;			}			startTimer();		}				public function stopTimer():void{			if (timer!=null) {				timer.removeEventListener(TimerEvent.TIMER,onTimer);				timer=null;			}		}		private function startTimer():void{			if (timer==null) {				timer=new Timer(_interval);				timer.addEventListener(TimerEvent.TIMER,onTimer);				timer.start();			}		}				public function set value(n:Number):void{			if(isNaN(n)) {				trace('Momentum.value=NaN');				return;			}			if(status==STATUS_RELEASED) {				valueLog=[];			}			status=STATUS_HOLD;			startTimer();			logged=true;			_currentValue=n;			//trace('set value '+n);			logValue();		}		public function get value():Number{						// overflow state			if(status==STATUS_OVERFLOW) {				trace('overflowTimer='+int(overflowTimer));				if(overflowTimer<overflowT1) {					// phase ii - cosine					_currentValue = overflowY1+(overflowYMax-overflowY1)*(1-Math.cos(overflowTimer/overflowT1*Math.PI))/2;					//trace('Cosine Phase '+int(_currentValue));				} else {					// phase i - deacceleration					_currentValue = overflowYMax-_overflowDeacceleration*Math.pow(overflowTimer-overflowT1,2)*.5;					trace('Slowdown Phase '+int(_currentValue));				}			} else {				//trace('Normal Value');			}						return _currentValue;					}				public function get speed():Number{			return _currentSpeed;		}				public function get inMotion():Boolean{			return (status!=STATUS_HOLD);		}				// release and enter inertia mode		public function release():void{			status=STATUS_RELEASED;						_decayTimer=_decayTime;			if(valueLog.length<1) {				_releaseSpeed=0;			} else {				_releaseSpeed=(valueLog[valueLog.length-1]-valueLog[0])/_bufferLength;			}			//trace('valueLog='+valueLog);			//trace('_releaseSpeed='+_releaseSpeed);		}				function logValue():void{			valueLog.push(_currentValue);			if(valueLog.length>_bufferLength+1) {				valueLog.shift();			}		}		function onTimer(e:TimerEvent):void{						switch(status) {								case STATUS_NORMALIZED:					status=STATUS_HOLD;					break;									case STATUS_OVERFLOW:					overflowTimer-=_interval;					if(overflowTimer<=0) {						trace('overflowTimer<=0');						_currentValue=overflowY1;						_currentSpeed=0;						status=STATUS_NORMALIZED;						overflowTimer=0;					}					break;								case STATUS_RELEASED:					_decayTimer=Math.max(0,_decayTimer-_interval);					_currentSpeed=_releaseSpeed*Math.pow(_decayTimer/_decayTime,3); // slowdown					// overflow detection					if(_currentValue>_maxValue||_currentValue<_minValue) {												if(_currentSpeed*_overflowDeacceleration<0) {							_overflowDeacceleration=-_overflowDeacceleration;						}												// setting overflow timer						status=STATUS_OVERFLOW;						overflowY0=_currentValue;						overflowY1=Math.min(_maxValue,Math.max(_minValue,overflowY0));						overflowSpeed=_currentSpeed/_interval;						overflowT2=overflowSpeed/_overflowDeacceleration;						overflowYMax=overflowY0+overflowSpeed*overflowT2+_overflowDeacceleration*Math.pow(overflowT2,2)*.5;						overflowTimer=overflowT=overflowT1+overflowSpeed/_overflowDeacceleration;												trace('--------------------');						trace('T1='+overflowT1);						trace('T2='+overflowT2);						trace('Timer='+overflowTimer);						trace('Y0='+overflowY0);						trace('Y1='+overflowY1);						trace('YMax='+overflowYMax);						trace('Speed0='+overflowSpeed);						trace('_currentSpeed='+_currentSpeed);						trace('--------------------');											} else {												// inertia mode						if(_currentSpeed==0) {							status=STATUS_HOLD;							stopTimer();						} else {							_currentValue+=_currentSpeed;						}											}					break;								case STATUS_HOLD:					// Auto-log Value					if(logged){						logged=false;					} else {						logValue();					}					break;							}					}	}}